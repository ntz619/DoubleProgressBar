I’ll keep your existing SDK listener/parsing/timer intact and only add minimal JS: a `sendMessage()` helper (exactly as provided), store latest scores, and when the timer hits 0 compare and send the correct Portals messages once.


```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game UI Scoreboard</title>

  <!-- Portals SDK -->
  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js?v=10005456"></script>

  <style>
    :root{
      --w: 720px;
      --h: 74px;

      --border: rgba(255,255,255,0.22);
      --divider: rgba(255,255,255,0.14);

      --panel: rgba(0,0,0,0.45);
      --panel2: rgba(0,0,0,0.55);

      --text: rgba(255,255,255,0.95);
      --shadow: rgba(0,0,0,0.65);

      --radius: 12px;
    }

    html, body{
      height: 100%;
      margin: 0;
      background: transparent;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
    }

    /* Center the whole UI on the canvas */
    .wrap{
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      box-sizing: border-box;
    }

    .stack{
      width: 100%;
      display: grid;
      justify-items: center;
      gap: 10px;
    }

    .hud{
      width: min(var(--w), 96vw);
      height: var(--h);
      display: flex;
      border-radius: var(--radius);
      overflow: hidden;

      border: 1px solid var(--border);
      box-shadow: none;
      transform: translateZ(0);
    }

    .hud > *{
      position: relative;
      height: 100%;
    }
    .hud > * + *{
      border-left: 1px solid var(--divider);
    }

    /* Team panels */
    .team{
      flex: 1 1 0;
      background: var(--panel);
      overflow: hidden;
    }

    /* Time panel */
    .timebox{
      width: 140px;
      background: var(--panel2);
      display: grid;
      place-items: center;
      text-align: center;
    }

    /* Fill layer */
    .fill{
      position: absolute;
      top: 0;
      bottom: 0;
      width: 0%;
      background: var(--fill);
      transition: width 450ms cubic-bezier(.2,.8,.2,1);
      will-change: width, transform, filter;
      z-index: 1;
    }

    /* Direction: fill away from center time */
    .team--red .fill{
      right: 0;    /* anchored to time side */
      left: auto;
    }
    .team--blue .fill{
      left: 0;     /* anchored to time side */
      right: auto;
    }

    /* Content layer */
    .label{
      position: absolute;
      top: 10px;
      font-size: 11px;
      letter-spacing: 0.22em;
      font-weight: 800;
      opacity: 0.95;
      z-index: 2;
      text-transform: uppercase;

      text-shadow:
        0 2px 8px var(--shadow),
        0 0 1px rgba(0,0,0,0.9);
      user-select: none;
      pointer-events: none;
    }

    .team--red .label{ left: 12px; }
    .team--blue .label{ right: 12px; }

    .score{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-weight: 900;
      font-size: 34px;
      line-height: 1;
      z-index: 2;

      text-shadow:
        0 2px 10px var(--shadow),
        0 0 1px rgba(0,0,0,0.9),
        0 0 12px rgba(0,0,0,0.35);
      user-select: none;
      pointer-events: none;
    }

    .timeLabel{
      position: absolute;
      top: 10px;
      font-size: 11px;
      letter-spacing: 0.22em;
      font-weight: 800;
      opacity: 0.95;
      text-transform: uppercase;
      z-index: 2;

      text-shadow:
        0 2px 8px var(--shadow),
        0 0 1px rgba(0,0,0,0.9);
      user-select: none;
      pointer-events: none;
    }

    .timeText{
      font-weight: 900;
      font-size: 26px;
      letter-spacing: 0.04em;
      z-index: 2;

      text-shadow:
        0 2px 10px var(--shadow),
        0 0 1px rgba(0,0,0,0.9);
      user-select: none;
      pointer-events: none;
    }

    .sub{
      opacity: 0.8;
      font-size: 12px;
      text-align: center;
    }

    /* Keep your "full" pop */
    .bar.full .fill{
      animation: fullPulse 900ms ease-out 1;
      filter: none;
    }
    .bar.full{
      animation: fullPop 650ms cubic-bezier(.2,.8,.2,1) 1;
    }

    @keyframes fullPop{
      0%   { transform: scale(1); }
      35%  { transform: scale(1.04); }
      70%  { transform: scale(0.99); }
      100% { transform: scale(1); }
    }
    @keyframes fullPulse{
      0%   { transform: scaleX(1); }
      40%  { transform: scaleX(1.01); }
      100% { transform: scaleX(1); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stack">
      <!-- Single-row HUD like the screenshot -->
      <div class="hud" aria-label="Scoreboard">
        <!-- LEFT (RED) -->
        <div
          class="team team--red bar"
          id="bar1"
          style="--fill:#DD1717;"
          role="progressbar"
          aria-valuemin="0"
          aria-valuemax="500"
          aria-valuenow="0"
        >
          <div class="fill" id="fill1"></div>
          <div class="label">RED</div>
          <div class="score" id="valueText1">0</div>
        </div>

        <!-- CENTER (TIME) -->
        <div class="timebox" aria-label="Time">
          <div class="timeLabel">TIME</div>
          <div class="timeText" id="timeText" aria-live="polite">5:00</div>
        </div>

        <!-- RIGHT (BLUE) -->
        <div
          class="team team--blue bar"
          id="bar2"
          style="--fill:#0018FF;"
          role="progressbar"
          aria-valuemin="0"
          aria-valuemax="500"
          aria-valuenow="0"
        >
          <div class="fill" id="fill2"></div>
          <div class="label">BLUE</div>
          <div class="score" id="valueText2">0</div>
        </div>
      </div>

      <div class="sub" id="debugText">Waiting for SDK message…</div>
    </div>
  </div>

  <script>
    const MIN = 0;
    const MAX = 500;

    const bar1 = document.getElementById('bar1');
    const fill1 = document.getElementById('fill1');
    const valueText1 = document.getElementById('valueText1');

    const bar2 = document.getElementById('bar2');
    const fill2 = document.getElementById('fill2');
    const valueText2 = document.getElementById('valueText2');

    const debugText = document.getElementById('debugText');

    // --- Portals sendMessage helper (do not change) ---
    function sendMessage(taskName, targetState) {
        const message = {
          TaskName: taskName,
          TaskTargetState: targetState
        };
        PortalsSdk.sendMessageToUnity(JSON.stringify(message));
      }

    // Track latest scores for end-of-round comparison
    let latestRedScore = 0;
    let latestBlueScore = 0;
    let didSendRoundResult = false;

    // --- Timer (starts on first received message) ---
    const START_SECONDS = 5 * 60;
    let countdownStartMs = null;
    let timerHandle = null;

    const timeText = document.getElementById('timeText');

    function renderTime(totalSeconds) {
      const s = Math.max(0, totalSeconds | 0);
      const m = Math.floor(s / 60);
      const r = s % 60;
      timeText.textContent = `${m}:${String(r).padStart(2, '0')}`;
    }

    function sendRoundResultIfNeeded() {
      if (didSendRoundResult) return;
      didSendRoundResult = true;

      // Always send round_finish, then the winner
      if (latestRedScore > latestBlueScore) {
        sendMessage('round_finish', 'SetNotActiveToActive');
        sendMessage('RedWins', 'SetNotActiveToActive');
      } else if (latestBlueScore > latestRedScore) {
        sendMessage('round_finish', 'SetNotActiveToActive');
        sendMessage('BlueWins', 'SetNotActiveToActive');
      } else {
        // Tie: only round_finish (no winner specified)
        sendMessage('round_finish', 'SetNotActiveToActive');
      }
    }

    function startCountdownIfNeeded() {
      if (timerHandle) return;

      countdownStartMs = Date.now();
      timerHandle = setInterval(() => {
        const elapsed = Math.floor((Date.now() - countdownStartMs) / 1000);
        const remaining = START_SECONDS - elapsed;

        renderTime(remaining);

        if (remaining <= 0) {
          clearInterval(timerHandle);
          timerHandle = null;
          renderTime(0);

          // Compare scores and send result when timer ends
          sendRoundResultIfNeeded();
        }
      }, 250);
    }

    // initialize display (not counting yet)
    renderTime(START_SECONDS);

    let wasFull1 = false;
    let wasFull2 = false;

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function setProgress(barEl, fillEl, valueEl, value, wasFull) {
      const v = clamp(value, MIN, MAX);
      const pct = (v / MAX) * 100;

      fillEl.style.width = pct.toFixed(2) + '%';
      valueEl.textContent = String(v);
      barEl.setAttribute('aria-valuenow', String(v));

      const isFull = (v >= MAX);

      // Play "full" animation only when crossing into full
      if (isFull && !wasFull) {
        barEl.classList.remove('full');
        void barEl.offsetWidth; // restart animation reliably
        barEl.classList.add('full');
      }

      if (barEl.classList.contains('full')) {
        clearTimeout(barEl._fullTimer);
        barEl._fullTimer = setTimeout(() => barEl.classList.remove('full'), 1000);
      }

      return isFull;
    }

    // Parse two integers from a strict numeric pair string, e.g. "123 45" or "123,45"
    function parseGreenBlue(message) {
      const str = String(message);

      // Only care about these parts anywhere in the string:
      //   Green=<int>  and  Blue=<int>
      const greenMatch = str.match(/\bGreen\s*=\s*([+-]?[0-9]+)\b/);
      const blueMatch  = str.match(/\bBlue\s*=\s*([+-]?[0-9]+)\b/);

      if (!greenMatch || !blueMatch) return null;

      const green = parseInt(greenMatch[1], 10);
      const blue  = parseInt(blueMatch[1], 10);
      if (!Number.isFinite(green) || !Number.isFinite(blue)) return null;

      return { green, blue };
    }

    // Assume PortalsSdk is present (no window checks)
    try {
      PortalsSdk.setMessageListener((message) => {
        console.log("PORTALS MSG:", message);

        // Start countdown on the first received message (any message)
        startCountdownIfNeeded();

        const parsed = parseGreenBlue(message);
        if (!parsed) {
          debugText.textContent = `Missing Green/Blue values in message: ${String(message)}`;
          return;
        }

        const topValue = parsed.green;
        const bottomValue = parsed.blue;

        // Store latest for timer-end comparison
        latestRedScore = topValue;
        latestBlueScore = bottomValue;

        debugText.textContent = `Green: ${topValue}  |  Blue: ${bottomValue}`;

        wasFull1 = setProgress(bar1, fill1, valueText1, topValue, wasFull1);
        wasFull2 = setProgress(bar2, fill2, valueText2, bottomValue, wasFull2);
      });

      debugText.textContent = "Listening for SDK messages…";
    } catch (e) {
      console.error(e);
      debugText.textContent = "PortalsSdk not available.";
    }

    wasFull1 = setProgress(bar1, fill1, valueText1, 0, wasFull1);
    wasFull2 = setProgress(bar2, fill2, valueText2, 0, wasFull2);
    PortalsSdk.focusGameKeyboard();
  </script>
</body>
</html>
